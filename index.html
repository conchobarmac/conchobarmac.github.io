<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Google Map with Multiple Polygons</title>
    <!-- Replace YOUR_API_KEY with your actual key -->
    <script src="https://maps.googleapis.com/maps/api/js?key=AIzaSyBX_I71Gwb4In2KPQPQhlJ9bzaFFsw7ITQ"></script>
    <style>
      html, body {
        margin: 0;
        padding: 0;
        height: 100%;
      }
      #map {
        width: 100%;
        height: 100%;
      }
    </style>
    <script>
      function initMap() {
        // Grab both 'field' and 'transect' query parameters
        const urlParams = new URLSearchParams(window.location.search);
        const fieldParam    = urlParams.get('field');
        const transectParam = urlParams.get('transect');

        // Create a satellite map with some placeholder center
        const map = new google.maps.Map(document.getElementById('map'), {
          center: { lat: 54.61, lng: -6.69 },
          zoom: 8,
          mapTypeId: 'satellite'
        });

        // We'll track overall bounding coords so we can fit everything together
        const overallBounds = new google.maps.LatLngBounds();

        // If there's a 'field' param, parse & draw it
        if (fieldParam) {
          try {
            const fieldGeojson = JSON.parse(fieldParam);
            drawGeoJsonShape(fieldGeojson, map, overallBounds, {
              strokeColor: '#FF0000',  // Field = red
              fillColor: '#FF0000'
            });
          } catch (e) {
            console.error("Error parsing 'field' GeoJSON:", e);
          }
        }

        // If there's a 'transect' param, parse & draw it
        if (transectParam) {
          try {
            const transectGeojson = JSON.parse(transectParam);
            drawGeoJsonShape(transectGeojson, map, overallBounds, {
              strokeColor: '#0000FF',  // Transect = blue
              fillColor: '#0000FF'
            });
          } catch (e) {
            console.error("Error parsing 'transect' GeoJSON:", e);
          }
        }

        // After drawing both (if any), fit the map to show everything
        // But only if the overallBounds is non-empty
        if (!overallBounds.isEmpty()) {
          map.fitBounds(overallBounds);
        }
      }

      // Helper function to draw a (Multi)Polygon from a GeoJSON object,
      // updating the map and bounds. 
      function drawGeoJsonShape(geojson, map, overallBounds, polygonOptions) {
        // Might be a FeatureCollection, Feature, or direct geometry object.
        // Letâ€™s unify it to a geometry object of type Polygon/MultiPolygon.

        // If it's a FeatureCollection, just take each Feature in turn
        if (geojson.type === "FeatureCollection") {
          geojson.features.forEach(feature => {
            drawSingleFeature(feature, map, overallBounds, polygonOptions);
          });
        } else if (geojson.type === "Feature") {
          drawSingleFeature(geojson, map, overallBounds, polygonOptions);
        } else {
          // It's presumably a geometry object
          const fakeFeature = { type: "Feature", geometry: geojson };
          drawSingleFeature(fakeFeature, map, overallBounds, polygonOptions);
        }
      }

      function drawSingleFeature(feature, map, overallBounds, polygonOptions) {
        const geometry = feature.geometry;
        if (!geometry || !(geometry.type === "Polygon" || geometry.type === "MultiPolygon")) {
          console.warn("Skipping non-polygon geometry:", geometry);
          return;
        }

        // Now handle (Multi)Polygon
        let polygons = [];

        if (geometry.type === "Polygon") {
          // geometry.coordinates = [ [ [lng, lat], [lng, lat], ... ] ]
          polygons.push(geometry.coordinates); 
        } else if (geometry.type === "MultiPolygon") {
          // geometry.coordinates = [ [ [ [lng, lat], [lng, lat], ... ] ], [ ... ] ]
          polygons = geometry.coordinates; 
        }

        polygons.forEach(rings => {
          // rings is an array of linear rings, the first ring is outer boundary, others are holes
          const outerRing = rings[0];
          // Convert [lng, lat] -> { lat, lng }
          const outerPath = outerRing.map(pt => ({ lat: pt[1], lng: pt[0] }));

          // For demonstration, we won't handle holes here, but you can convert rings[1], rings[2], etc. similarly
          const polygon = new google.maps.Polygon({
            paths: outerPath,
            strokeWeight: 2,
            fillOpacity: 0.2,
            ...polygonOptions // spread the user-chosen strokeColor, fillColor, etc.
          });

          polygon.setMap(map);

          // Expand overall bounds
          outerPath.forEach(coord => overallBounds.extend(coord));
        });
      }
    </script>
  </head>
  <body onload="initMap()">
    <div id="map"></div>
  </body>
</html>